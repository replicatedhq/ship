
---
# assets are everything an end customer needs to deploy your application, like
#
#  - kubernetes or docker-compose manifests
#  - installation scripts
#  - modules for ansible/chef/puppet
#  - private docker images
#  - compiled artifacts and binaries
#
# assets will be templated using customer-supplied
# install info from the "config" section (below)
assets:
  v1:
    # "inline" can be used to supply assets directly in the spec
    - inline:
        contents: |
          #!/bin/bash
          echo "Asset not ignored"
        dest: ./scripts/not-ignored.sh
        mode: 0777
        when: '{{repl ConfigOptionEquals "bool_option" "0"}}'
    - inline:
        contents: |
          #!/bin/bash
          echo "Asset ignored"
        dest: ./scripts/ignored.sh
        mode: 0777
        when: '{{repl ConfigOptionEquals "bool_option" "1"}}'
    - docker:
        dest: ./images/postgres.tar
        image: postgres:10.1
        source: public
        when: '{{repl ConfigOptionEquals "bool_option" "1"}}'

# Config defines the configuration options available to your application.
# Values supplied by the end customer will be used during asset generation.
config:
  v1:
    - name: test_options
      title: Test Options
      description: testing testing 123
      items:
      - name: bool_option
        title: Boolean Option
        type: bool
        default: "0"

# Lifecycle allows you to customize the messaging and workflow for your end customer
# when they are generating assets. Currently the two support lifecycle steps are
#
#  - message -- prints a message
#  - render  -- collects config and generates assets
lifecycle:
  v1:
    - render: {}
